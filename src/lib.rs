/* automatically generated by rust-bindgen 0.72.1 */
#![allow(non_camel_case_types)]

pub const LBFGS_FLOAT: u32 = 64;
pub const LBFGS_IEEE_FLOAT: u32 = 1;
pub type lbfgsfloatval_t = f64;
#[doc = " L-BFGS reaches convergence."]
pub const LBFGS_SUCCESS: _bindgen_ty_1 = 0;
#[doc = " L-BFGS reaches convergence."]
pub const LBFGS_CONVERGENCE: _bindgen_ty_1 = 0;
#[doc = " L-BFGS reaches convergence."]
pub const LBFGS_STOP: _bindgen_ty_1 = 1;
#[doc = " The initial variables already minimize the objective function."]
pub const LBFGS_ALREADY_MINIMIZED: _bindgen_ty_1 = 2;
#[doc = " Unknown error."]
pub const LBFGSERR_UNKNOWNERROR: _bindgen_ty_1 = -1024;
#[doc = " Logic error."]
pub const LBFGSERR_LOGICERROR: _bindgen_ty_1 = -1023;
#[doc = " Insufficient memory."]
pub const LBFGSERR_OUTOFMEMORY: _bindgen_ty_1 = -1022;
#[doc = " The minimization process has been canceled."]
pub const LBFGSERR_CANCELED: _bindgen_ty_1 = -1021;
#[doc = " Invalid number of variables specified."]
pub const LBFGSERR_INVALID_N: _bindgen_ty_1 = -1020;
#[doc = " Invalid number of variables (for SSE) specified."]
pub const LBFGSERR_INVALID_N_SSE: _bindgen_ty_1 = -1019;
#[doc = " The array x must be aligned to 16 (for SSE)."]
pub const LBFGSERR_INVALID_X_SSE: _bindgen_ty_1 = -1018;
#[doc = " Invalid parameter lbfgs_parameter_t::epsilon specified."]
pub const LBFGSERR_INVALID_EPSILON: _bindgen_ty_1 = -1017;
#[doc = " Invalid parameter lbfgs_parameter_t::past specified."]
pub const LBFGSERR_INVALID_TESTPERIOD: _bindgen_ty_1 = -1016;
#[doc = " Invalid parameter lbfgs_parameter_t::delta specified."]
pub const LBFGSERR_INVALID_DELTA: _bindgen_ty_1 = -1015;
#[doc = " Invalid parameter lbfgs_parameter_t::linesearch specified."]
pub const LBFGSERR_INVALID_LINESEARCH: _bindgen_ty_1 = -1014;
#[doc = " Invalid parameter lbfgs_parameter_t::max_step specified."]
pub const LBFGSERR_INVALID_MINSTEP: _bindgen_ty_1 = -1013;
#[doc = " Invalid parameter lbfgs_parameter_t::max_step specified."]
pub const LBFGSERR_INVALID_MAXSTEP: _bindgen_ty_1 = -1012;
#[doc = " Invalid parameter lbfgs_parameter_t::ftol specified."]
pub const LBFGSERR_INVALID_FTOL: _bindgen_ty_1 = -1011;
#[doc = " Invalid parameter lbfgs_parameter_t::wolfe specified."]
pub const LBFGSERR_INVALID_WOLFE: _bindgen_ty_1 = -1010;
#[doc = " Invalid parameter lbfgs_parameter_t::gtol specified."]
pub const LBFGSERR_INVALID_GTOL: _bindgen_ty_1 = -1009;
#[doc = " Invalid parameter lbfgs_parameter_t::xtol specified."]
pub const LBFGSERR_INVALID_XTOL: _bindgen_ty_1 = -1008;
#[doc = " Invalid parameter lbfgs_parameter_t::max_linesearch specified."]
pub const LBFGSERR_INVALID_MAXLINESEARCH: _bindgen_ty_1 = -1007;
#[doc = " Invalid parameter lbfgs_parameter_t::orthantwise_c specified."]
pub const LBFGSERR_INVALID_ORTHANTWISE: _bindgen_ty_1 = -1006;
#[doc = " Invalid parameter lbfgs_parameter_t::orthantwise_start specified."]
pub const LBFGSERR_INVALID_ORTHANTWISE_START: _bindgen_ty_1 = -1005;
#[doc = " Invalid parameter lbfgs_parameter_t::orthantwise_end specified."]
pub const LBFGSERR_INVALID_ORTHANTWISE_END: _bindgen_ty_1 = -1004;
#[doc = " The line-search step went out of the interval of uncertainty."]
pub const LBFGSERR_OUTOFINTERVAL: _bindgen_ty_1 = -1003;
#[doc = " A logic error occurred; alternatively, the interval of uncertainty\nbecame too small."]
pub const LBFGSERR_INCORRECT_TMINMAX: _bindgen_ty_1 = -1002;
#[doc = " A rounding error occurred; alternatively, no line-search step\nsatisfies the sufficient decrease and curvature conditions."]
pub const LBFGSERR_ROUNDING_ERROR: _bindgen_ty_1 = -1001;
#[doc = " The line-search step became smaller than lbfgs_parameter_t::min_step."]
pub const LBFGSERR_MINIMUMSTEP: _bindgen_ty_1 = -1000;
#[doc = " The line-search step became larger than lbfgs_parameter_t::max_step."]
pub const LBFGSERR_MAXIMUMSTEP: _bindgen_ty_1 = -999;
#[doc = " The line-search routine reaches the maximum number of evaluations."]
pub const LBFGSERR_MAXIMUMLINESEARCH: _bindgen_ty_1 = -998;
#[doc = " The algorithm routine reaches the maximum number of iterations."]
pub const LBFGSERR_MAXIMUMITERATION: _bindgen_ty_1 = -997;
#[doc = " Relative width of the interval of uncertainty is at most\nlbfgs_parameter_t::xtol."]
pub const LBFGSERR_WIDTHTOOSMALL: _bindgen_ty_1 = -996;
#[doc = " A logic error (negative line-search step) occurred."]
pub const LBFGSERR_INVALIDPARAMETERS: _bindgen_ty_1 = -995;
#[doc = " The current search direction increases the objective function value."]
pub const LBFGSERR_INCREASEGRADIENT: _bindgen_ty_1 = -994;
#[doc = " Return values of lbfgs().\n\n  Roughly speaking, a negative value indicates an error."]
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
#[doc = " The default algorithm (MoreThuente method)."]
pub const LBFGS_LINESEARCH_DEFAULT: _bindgen_ty_2 = 0;
#[doc = " MoreThuente method proposd by More and Thuente."]
pub const LBFGS_LINESEARCH_MORETHUENTE: _bindgen_ty_2 = 0;
#[doc = " Backtracking method with the Armijo condition.\n  The backtracking method finds the step length such that it satisfies\n  the sufficient decrease (Armijo) condition,\n    - f(x + a * d) <= f(x) + lbfgs_parameter_t::ftol * a * g(x)^T d,\n\n  where x is the current point, d is the current search direction, and\n  a is the step length."]
pub const LBFGS_LINESEARCH_BACKTRACKING_ARMIJO: _bindgen_ty_2 = 1;
#[doc = " The backtracking method with the defualt (regular Wolfe) condition."]
pub const LBFGS_LINESEARCH_BACKTRACKING: _bindgen_ty_2 = 2;
#[doc = " Backtracking method with regular Wolfe condition.\n  The backtracking method finds the step length such that it satisfies\n  both the Armijo condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)\n  and the curvature condition,\n    - g(x + a * d)^T d >= lbfgs_parameter_t::wolfe * g(x)^T d,\n\n  where x is the current point, d is the current search direction, and\n  a is the step length."]
pub const LBFGS_LINESEARCH_BACKTRACKING_WOLFE: _bindgen_ty_2 = 2;
#[doc = " Backtracking method with strong Wolfe condition.\n  The backtracking method finds the step length such that it satisfies\n  both the Armijo condition (LBFGS_LINESEARCH_BACKTRACKING_ARMIJO)\n  and the following condition,\n    - |g(x + a * d)^T d| <= lbfgs_parameter_t::wolfe * |g(x)^T d|,\n\n  where x is the current point, d is the current search direction, and\n  a is the step length."]
pub const LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE: _bindgen_ty_2 = 3;
#[doc = " Line search algorithms."]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = " L-BFGS optimization parameters.\n  Call lbfgs_parameter_init() function to initialize parameters to the\n  default values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lbfgs_parameter_t {
    #[doc = " The number of corrections to approximate the inverse hessian matrix.\n  The L-BFGS routine stores the computation results of previous \\ref m\n  iterations to approximate the inverse hessian matrix of the current\n  iteration. This parameter controls the size of the limited memories\n  (corrections). The default value is \\c 6. Values less than \\c 3 are\n  not recommended. Large values will result in excessive computing time."]
    pub m: ::std::os::raw::c_int,
    #[doc = " Epsilon for convergence test.\n  This parameter determines the accuracy with which the solution is to\n  be found. A minimization terminates when\n      ||g|| < \\ref epsilon * max(1, ||x||),\n  where ||.|| denotes the Euclidean (L2) norm. The default value is\n  \\c 1e-5."]
    pub epsilon: lbfgsfloatval_t,
    #[doc = " Distance for delta-based convergence test.\n  This parameter determines the distance, in iterations, to compute\n  the rate of decrease of the objective function. If the value of this\n  parameter is zero, the library does not perform the delta-based\n  convergence test. The default value is \\c 0."]
    pub past: ::std::os::raw::c_int,
    #[doc = " Delta for convergence test.\n  This parameter determines the minimum rate of decrease of the\n  objective function. The library stops iterations when the\n  following condition is met:\n      (f' - f) / f < \\ref delta,\n  where f' is the objective value of \\ref past iterations ago, and f is\n  the objective value of the current iteration.\n  The default value is \\c 1e-5."]
    pub delta: lbfgsfloatval_t,
    #[doc = " The maximum number of iterations.\n  The lbfgs() function terminates an optimization process with\n  ::LBFGSERR_MAXIMUMITERATION status code when the iteration count\n  exceedes this parameter. Setting this parameter to zero continues an\n  optimization process until a convergence or error. The default value\n  is \\c 0."]
    pub max_iterations: ::std::os::raw::c_int,
    #[doc = " The line search algorithm.\n  This parameter specifies a line search algorithm to be used by the\n  L-BFGS routine."]
    pub linesearch: ::std::os::raw::c_int,
    #[doc = " The maximum number of trials for the line search.\n  This parameter controls the number of function and gradients evaluations\n  per iteration for the line search routine. The default value is \\c 40."]
    pub max_linesearch: ::std::os::raw::c_int,
    #[doc = " The minimum step of the line search routine.\n  The default value is \\c 1e-20. This value need not be modified unless\n  the exponents are too large for the machine being used, or unless the\n  problem is extremely badly scaled (in which case the exponents should\n  be increased)."]
    pub min_step: lbfgsfloatval_t,
    #[doc = " The maximum step of the line search.\n  The default value is \\c 1e+20. This value need not be modified unless\n  the exponents are too large for the machine being used, or unless the\n  problem is extremely badly scaled (in which case the exponents should\n  be increased)."]
    pub max_step: lbfgsfloatval_t,
    #[doc = " A parameter to control the accuracy of the line search routine.\n  The default value is \\c 1e-4. This parameter should be greater\n  than zero and smaller than \\c 0.5."]
    pub ftol: lbfgsfloatval_t,
    #[doc = " A coefficient for the Wolfe condition.\n  This parameter is valid only when the backtracking line-search\n  algorithm is used with the Wolfe condition,\n  ::LBFGS_LINESEARCH_BACKTRACKING_STRONG_WOLFE or\n  ::LBFGS_LINESEARCH_BACKTRACKING_WOLFE .\n  The default value is \\c 0.9. This parameter should be greater\n  the \\ref ftol parameter and smaller than \\c 1.0."]
    pub wolfe: lbfgsfloatval_t,
    #[doc = " A parameter to control the accuracy of the line search routine.\n  The default value is \\c 0.9. If the function and gradient\n  evaluations are inexpensive with respect to the cost of the\n  iteration (which is sometimes the case when solving very large\n  problems) it may be advantageous to set this parameter to a small\n  value. A typical small value is \\c 0.1. This parameter should be\n  greater than the \\ref ftol parameter (\\c 1e-4) and smaller than\n  \\c 1.0."]
    pub gtol: lbfgsfloatval_t,
    #[doc = " The machine precision for floating-point values.\n  This parameter must be a positive value set by a client program to\n  estimate the machine precision. The line search routine will terminate\n  with the status code (::LBFGSERR_ROUNDING_ERROR) if the relative width\n  of the interval of uncertainty is less than this parameter."]
    pub xtol: lbfgsfloatval_t,
    #[doc = " Coeefficient for the L1 norm of variables.\n  This parameter should be set to zero for standard minimization\n  problems. Setting this parameter to a positive value activates\n  Orthant-Wise Limited-memory Quasi-Newton (OWL-QN) method, which\n  minimizes the objective function F(x) combined with the L1 norm |x|\n  of the variables, {F(x) + C |x|}. This parameter is the coeefficient\n  for the |x|, i.e., C. As the L1 norm |x| is not differentiable at\n  zero, the library modifies function and gradient evaluations from\n  a client program suitably; a client program thus have only to return\n  the function value F(x) and gradients G(x) as usual. The default value\n  is zero."]
    pub orthantwise_c: lbfgsfloatval_t,
    #[doc = " Start index for computing L1 norm of the variables.\n  This parameter is valid only for OWL-QN method\n  (i.e., \\ref orthantwise_c != 0). This parameter b (0 <= b < N)\n  specifies the index number from which the library computes the\n  L1 norm of the variables x,\n      |x| := |x_{b}| + |x_{b+1}| + ... + |x_{N}| .\n  In other words, variables x_1, ..., x_{b-1} are not used for\n  computing the L1 norm. Setting b (0 < b < N), one can protect\n  variables, x_1, ..., x_{b-1} (e.g., a bias term of logistic\n  regression) from being regularized. The default value is zero."]
    pub orthantwise_start: ::std::os::raw::c_int,
    #[doc = " End index for computing L1 norm of the variables.\n  This parameter is valid only for OWL-QN method\n  (i.e., \\ref orthantwise_c != 0). This parameter e (0 < e <= N)\n  specifies the index number at which the library stops computing the\n  L1 norm of the variables x,"]
    pub orthantwise_end: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lbfgs_parameter_t"][::std::mem::size_of::<lbfgs_parameter_t>() - 112usize];
    ["Alignment of lbfgs_parameter_t"][::std::mem::align_of::<lbfgs_parameter_t>() - 8usize];
    ["Offset of field: lbfgs_parameter_t::m"]
        [::std::mem::offset_of!(lbfgs_parameter_t, m) - 0usize];
    ["Offset of field: lbfgs_parameter_t::epsilon"]
        [::std::mem::offset_of!(lbfgs_parameter_t, epsilon) - 8usize];
    ["Offset of field: lbfgs_parameter_t::past"]
        [::std::mem::offset_of!(lbfgs_parameter_t, past) - 16usize];
    ["Offset of field: lbfgs_parameter_t::delta"]
        [::std::mem::offset_of!(lbfgs_parameter_t, delta) - 24usize];
    ["Offset of field: lbfgs_parameter_t::max_iterations"]
        [::std::mem::offset_of!(lbfgs_parameter_t, max_iterations) - 32usize];
    ["Offset of field: lbfgs_parameter_t::linesearch"]
        [::std::mem::offset_of!(lbfgs_parameter_t, linesearch) - 36usize];
    ["Offset of field: lbfgs_parameter_t::max_linesearch"]
        [::std::mem::offset_of!(lbfgs_parameter_t, max_linesearch) - 40usize];
    ["Offset of field: lbfgs_parameter_t::min_step"]
        [::std::mem::offset_of!(lbfgs_parameter_t, min_step) - 48usize];
    ["Offset of field: lbfgs_parameter_t::max_step"]
        [::std::mem::offset_of!(lbfgs_parameter_t, max_step) - 56usize];
    ["Offset of field: lbfgs_parameter_t::ftol"]
        [::std::mem::offset_of!(lbfgs_parameter_t, ftol) - 64usize];
    ["Offset of field: lbfgs_parameter_t::wolfe"]
        [::std::mem::offset_of!(lbfgs_parameter_t, wolfe) - 72usize];
    ["Offset of field: lbfgs_parameter_t::gtol"]
        [::std::mem::offset_of!(lbfgs_parameter_t, gtol) - 80usize];
    ["Offset of field: lbfgs_parameter_t::xtol"]
        [::std::mem::offset_of!(lbfgs_parameter_t, xtol) - 88usize];
    ["Offset of field: lbfgs_parameter_t::orthantwise_c"]
        [::std::mem::offset_of!(lbfgs_parameter_t, orthantwise_c) - 96usize];
    ["Offset of field: lbfgs_parameter_t::orthantwise_start"]
        [::std::mem::offset_of!(lbfgs_parameter_t, orthantwise_start) - 104usize];
    ["Offset of field: lbfgs_parameter_t::orthantwise_end"]
        [::std::mem::offset_of!(lbfgs_parameter_t, orthantwise_end) - 108usize];
};
#[doc = " Callback interface to provide objective function and gradient evaluations.\n\n  The lbfgs() function call this function to obtain the values of objective\n  function and its gradients when needed. A client program must implement\n  this function to evaluate the values of the objective function and its\n  gradients, given current values of variables.\n\n  @param  instance    The user data sent for lbfgs() function by the client.\n  @param  x           The current values of variables.\n  @param  g           The gradient vector. The callback function must compute\n                      the gradient values for the current variables.\n  @param  n           The number of variables.\n  @param  step        The current step of the line search routine.\n  @retval lbfgsfloatval_t The value of the objective function for the current\n                          variables."]
pub type lbfgs_evaluate_t = ::std::option::Option<
    unsafe extern "C" fn(
        instance: *mut ::std::os::raw::c_void,
        x: *const lbfgsfloatval_t,
        g: *mut lbfgsfloatval_t,
        n: ::std::os::raw::c_int,
        step: lbfgsfloatval_t,
    ) -> lbfgsfloatval_t,
>;
#[doc = " Callback interface to receive the progress of the optimization process.\n\n  The lbfgs() function call this function for each iteration. Implementing\n  this function, a client program can store or display the current progress\n  of the optimization process.\n\n  @param  instance    The user data sent for lbfgs() function by the client.\n  @param  x           The current values of variables.\n  @param  g           The current gradient values of variables.\n  @param  fx          The current value of the objective function.\n  @param  xnorm       The Euclidean norm of the variables.\n  @param  gnorm       The Euclidean norm of the gradients.\n  @param  step        The line-search step used for this iteration.\n  @param  n           The number of variables.\n  @param  k           The iteration count.\n  @param  ls          The number of evaluations called for this iteration.\n  @retval int         Zero to continue the optimization process. Returning a\n                      non-zero value will cancel the optimization process."]
pub type lbfgs_progress_t = ::std::option::Option<
    unsafe extern "C" fn(
        instance: *mut ::std::os::raw::c_void,
        x: *const lbfgsfloatval_t,
        g: *const lbfgsfloatval_t,
        fx: lbfgsfloatval_t,
        xnorm: lbfgsfloatval_t,
        gnorm: lbfgsfloatval_t,
        step: lbfgsfloatval_t,
        n: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        ls: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Start a L-BFGS optimization.\n\n  @param  n           The number of variables.\n  @param  x           The array of variables. A client program can set\n                      default values for the optimization and receive the\n                      optimization result through this array. This array\n                      must be allocated by ::lbfgs_malloc function\n                      for libLBFGS built with SSE/SSE2 optimization routine\n                      enabled. The library built without SSE/SSE2\n                      optimization does not have such a requirement.\n  @param  ptr_fx      The pointer to the variable that receives the final\n                      value of the objective function for the variables.\n                      This argument can be set to \\c NULL if the final\n                      value of the objective function is unnecessary.\n  @param  proc_evaluate   The callback function to provide function and\n                          gradient evaluations given a current values of\n                          variables. A client program must implement a\n                          callback function compatible with \\ref\n                          lbfgs_evaluate_t and pass the pointer to the\n                          callback function.\n  @param  proc_progress   The callback function to receive the progress\n                          (the number of iterations, the current value of\n                          the objective function) of the minimization\n                          process. This argument can be set to \\c NULL if\n                          a progress report is unnecessary.\n  @param  instance    A user data for the client program. The callback\n                      functions will receive the value of this argument.\n  @param  param       The pointer to a structure representing parameters for\n                      L-BFGS optimization. A client program can set this\n                      parameter to \\c NULL to use the default parameters.\n                      Call lbfgs_parameter_init() function to fill a\n                      structure with the default values.\n  @retval int         The status code. This function returns zero if the\n                      minimization process terminates without an error. A\n                      non-zero value indicates an error."]
    pub fn lbfgs(
        n: ::std::os::raw::c_int,
        x: *mut lbfgsfloatval_t,
        ptr_fx: *mut lbfgsfloatval_t,
        proc_evaluate: lbfgs_evaluate_t,
        proc_progress: lbfgs_progress_t,
        instance: *mut ::std::os::raw::c_void,
        param: *mut lbfgs_parameter_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize L-BFGS parameters to the default values.\n\n  Call this function to fill a parameter structure with the default values\n  and overwrite parameter values if necessary.\n\n  @param  param       The pointer to the parameter structure."]
    pub fn lbfgs_parameter_init(param: *mut lbfgs_parameter_t);
}
unsafe extern "C" {
    #[doc = " Allocate an array for variables.\n\n  This function allocates an array of variables for the convenience of\n  ::lbfgs function; the function has a requreiemt for a variable array\n  when libLBFGS is built with SSE/SSE2 optimization routines. A user does\n  not have to use this function for libLBFGS built without SSE/SSE2\n  optimization.\n\n  @param  n           The number of variables."]
    pub fn lbfgs_malloc(n: ::std::os::raw::c_int) -> *mut lbfgsfloatval_t;
}
unsafe extern "C" {
    #[doc = " Free an array of variables.\n\n  @param  x           The array of variables allocated by ::lbfgs_malloc\n                      function."]
    pub fn lbfgs_free(x: *mut lbfgsfloatval_t);
}
unsafe extern "C" {
    #[doc = " Get string description of an lbfgs() return code.\n\n  @param err          A value returned by lbfgs()."]
    pub fn lbfgs_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
